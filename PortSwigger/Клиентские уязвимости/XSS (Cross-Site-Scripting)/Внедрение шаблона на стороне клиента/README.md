Внедрение шаблона на стороне клиента
В этом разделе мы рассмотрим уязвимости внедрения шаблонов на стороне клиента и то, как вы можете использовать их для атак XSS. Этот метод атаки был впервые применен нашей исследовательской группой — подробнее читайте в XSS без HTML: внедрение шаблонов на стороне клиента с помощью AngularJS . Хотя внедрение шаблонов на стороне клиента является общей проблемой, мы сосредоточимся на примерах из фреймворка AngularJS, поскольку это наиболее распространенная проблема. Мы опишем, как вы можете создавать эксплойты, которые выходят за пределы песочницы AngularJS, и как вы можете потенциально использовать функции AngularJS для обхода политики безопасности контента (CSP).

Что такое внедрение шаблона на стороне клиента?
Уязвимости внедрения шаблонов на стороне клиента возникают, когда приложения, использующие фреймворк шаблонов на стороне клиента, динамически встраивают пользовательский ввод в веб-страницы. При рендеринге страницы фреймворк сканирует ее на предмет выражений шаблонов и выполняет все, с которыми сталкивается. Злоумышленник может воспользоваться этим, предоставив вредоносное выражение шаблона, которое запускает атаку межсайтового скриптинга (XSS).

Что такое песочница AngularJS?
Песочница AngularJS — это механизм, который предотвращает доступ к потенциально опасным объектам, таким как windowили document, в выражениях шаблонов AngularJS. Он также предотвращает доступ к потенциально опасным свойствам, таким как __proto__. Несмотря на то, что команда AngularJS не считает это границей безопасности, более широкое сообщество разработчиков в целом думает иначе. Хотя обход песочницы изначально был сложным, исследователи безопасности обнаружили множество способов сделать это. В результате он был в конечном итоге удален из AngularJS в версии 1.6. Однако многие устаревшие приложения по-прежнему используют старые версии AngularJS и могут быть уязвимы в результате.

Как работает песочница AngularJS?
Песочница работает, анализируя выражение, переписывая JavaScript, а затем используя различные функции для проверки того, содержит ли переписанный код какие-либо опасные объекты. Например, функция ensureSafeObject()проверяет, ссылается ли данный объект на себя. Это один из способов обнаружения объекта window, например. FunctionКонструктор обнаруживается примерно таким же образом, проверяя, ссылается ли свойство конструктора на себя.

Функция ensureSafeMemberName()проверяет каждый доступ к свойству объекта и, если он содержит опасные свойства, такие как __proto__или __lookupGetter__, объект будет заблокирован. ensureSafeFunction()Функция предотвращает вызов call(), apply(), bind(), или .constructor()

Вы можете увидеть песочницу в действии, посетив этот скрипт и установив точку останова на строке 13275 файла angular.js. Переменная fnStringсодержит ваш переписанный код, поэтому вы можете посмотреть, как AngularJS преобразует его.

Как работает выход из песочницы AngularJS?
Побег из песочницы заключается в том, чтобы заставить песочницу думать, что вредоносное выражение является безвредным. Наиболее известный побег использует измененную charAt()функцию глобально внутри выражения:

'a'.constructor.prototype.charAt=[].join
Когда это было первоначально обнаружено, AngularJS не предотвратил эту модификацию. Атака работает путем перезаписи функции с использованием [].joinметода, который заставляет charAt()функцию возвращать все отправленные ей символы, а не конкретный одиночный символ. Из-за логики функции isIdent()в AngularJS она сравнивает то, что она считает одним символом, с несколькими символами. Поскольку одиночные символы всегда меньше нескольких символов, функция isIdent()всегда возвращает true, как показано в следующем примере:

isIdent = function(ch) {
    return ('a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$');
}
isIdent('x9=9a9l9e9r9t9(919)')
После того, как isIdent()функция обманута, вы можете внедрить вредоносный JavaScript. Например, выражение, такое как $eval('x=alert(1)')будет разрешено, поскольку AngularJS обрабатывает каждый символ как идентификатор. Обратите внимание, что нам нужно использовать $eval()функцию AngularJS, поскольку перезапись charAt()функции вступит в силу только после выполнения изолированного кода. Этот метод затем обойдет песочницу и позволит выполнить произвольное выполнение JavaScript. PortSwigger Research полностью взломал песочницу AngularJS, несколько раз .
