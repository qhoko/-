Помимо извлечения конфиденциальных данных, другим основным последствием атак XXE является то, что они могут быть использованы для подделки запросов на стороне сервера (SSRF). Это потенциально серьезная уязвимость, при которой серверное приложение может быть вынуждено делать HTTP-запросы на любой URL, к которому сервер может получить доступ.

Чтобы использовать уязвимость XXE для выполнения атаки SSRF, вам необходимо определить внешнюю сущность XML с использованием URL, на который вы хотите нацелиться, и использовать определенную сущность в значении данных. Если вы можете использовать определенную сущность в значении данных, которое возвращается в ответе приложения, то вы сможете просмотреть ответ из URL в ответе приложения и, таким образом, получить двустороннее взаимодействие с внутренней системой. Если нет, то вы сможете выполнять только слепые атаки SSRF (которые все еще могут иметь критические последствия).

В следующем примере XXE внешний объект заставит сервер выполнить внутренний HTTP-запрос к внутренней системе в инфраструктуре организации:

<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal.vulnerable-website.com/"> ]>

В этой лабораторной работе есть функция «Проверка запасов», которая анализирует входные данные XML и возвращает любые непредвиденные значения в ответе.

На лабораторном сервере запущена (симулированная) конечная точка метаданных EC2 по URL-адресу по умолчанию, который является http://169.254.169.254/. Эта конечная точка может использоваться для извлечения данных об экземпляре, некоторые из которых могут быть конфиденциальными.

Для решения лабораторной задачи воспользуйтесь уязвимостью XXE для выполнения атаки SSRF, которая получит секретный ключ доступа IAM сервера из конечной точки метаданных EC2.

1.Нас встречает список продуктов, выбираем любой из них: 

![image](https://github.com/user-attachments/assets/5b1c2835-49a4-4c35-a8f6-868e64b152b0)

---

2. Включаем бурп прокси и нажимаем "Проверить наличие на складе"

![image](https://github.com/user-attachments/assets/befde5fc-be41-4db5-b1ea-157f5f333b26)

---

3. В Proxy -> HTTP History POST запрос к /product/stock отпраляем в Repeater:

![image](https://github.com/user-attachments/assets/1ca2ef83-dade-4541-9769-49efdf5b66ec)

---

4. Вставлем следующее определение внешней сущности между декларацией XML и stockCheck элементом: <!DOCTYPE eyes [ <!ENTITY ears SYSTEM "http://169.254.169.254/"> ] >, и значение ProductId меняем ссылкой на внешнюю сущность &ears;:

![image](https://github.com/user-attachments/assets/07499e10-bfeb-4136-b7e3-40bf768b2721)

---

5. Ответ должен содержать «Недопустимый идентификатор продукта:», за которым следует ответ от конечной точки метаданных, которая изначально будет именем папки:

![image](https://github.com/user-attachments/assets/3423349d-50a9-47c4-9577-bb8dfe43d3d8)

---

6. Итеративно обновляем конечную точку URL в DTD, чтобы исследовать API, пока не достигнете /latest/meta-data/iam/security-credentials/admin. Это должно вернуть JSON, содержащий SecretAccessKey: 

![image](https://github.com/user-attachments/assets/75bdacca-9636-450b-bef0-e1d441ca4f9b)
