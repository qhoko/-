Как предотвратить XSS
В этом разделе мы опишем некоторые общие принципы предотвращения уязвимостей межсайтового скриптинга и способы использования различных распространенных технологий для защиты от XSS-атак.

Предотвращение межсайтового скриптинга обычно достигается с помощью двух уровней защиты:

Кодировать данные на выходе
Проверить ввод по прибытии
Вы можете использовать Burp Scanner для сканирования ваших веб-сайтов на предмет многочисленных уязвимостей безопасности, включая XSS. Передовая логика сканирования Burp воспроизводит действия опытного злоумышленника и способна достичь соответственно высокого покрытия уязвимостей XSS. Вы можете использовать Burp Scanner, чтобы убедиться, что ваша защита от атак XSS работает эффективно.

Узнайте больше о сканере отрыжки
Кодировать данные на выходе
Кодирование должно применяться непосредственно перед записью контролируемых пользователем данных на страницу, поскольку контекст, в который вы пишете, определяет, какой тип кодирования вам нужно использовать. Например, значения внутри строки JavaScript требуют другого типа экранирования, чем в контексте HTML.

В контексте HTML следует преобразовать не входящие в белый список значения в сущности HTML:

<преобразуется в:&lt;
>преобразуется в:&gt;
В контексте строки JavaScript небуквенно-цифровые значения должны быть экранированы с помощью Unicode:

<преобразуется в:\u003c
>преобразуется в:\u003e
Иногда вам нужно будет применить несколько слоев кодирования в правильном порядке. Например, чтобы безопасно встроить пользовательский ввод в обработчик событий, вам нужно иметь дело как с контекстом JavaScript, так и с контекстом HTML. Поэтому вам нужно сначала экранировать ввод в Unicode, а затем закодировать его в HTML:

<a href="#" onclick="x='This string needs two layers of escaping'">test</a>
Проверить ввод по прибытии
Кодирование, вероятно, является наиболее важной линией защиты XSS, но его недостаточно для предотвращения уязвимостей XSS в каждом контексте. Вам также следует как можно строже проверять вводимые данные в момент их первого получения от пользователя.

Примеры проверки входных данных включают в себя:

Если пользователь отправляет URL, который будет возвращен в ответах, проверяя, что он начинается с безопасного протокола, такого как HTTP и HTTPS. В противном случае кто-то может использовать ваш сайт с вредоносным протоколом, таким как javascriptили data.
Если пользователь вводит значение, которое, как он ожидал, является числовым, проверяется, что значение на самом деле содержит целое число.
Проверка того, что входные данные содержат только ожидаемый набор символов.
Проверка ввода в идеале должна работать, блокируя недействительный ввод. Альтернативный подход, заключающийся в попытке очистить недействительный ввод, чтобы сделать его действительным, более подвержен ошибкам и его следует избегать, где это возможно.

Белый список против черного списка
Проверка ввода должна, как правило, использовать белые списки, а не черные. Например, вместо того, чтобы пытаться составить список всех вредоносных протоколов ( javascript, data, и т. д.), просто составьте список безопасных протоколов (HTTP, HTTPS) и запретите все, что не входит в список. Это гарантирует, что ваша защита не сломается при появлении новых вредоносных протоколов и сделает ее менее восприимчивой к атакам, которые стремятся скрыть недействительные значения, чтобы обойти черный список.

Разрешение «безопасного» HTML
По возможности следует избегать разрешения пользователям размещать HTML-разметку, но иногда это является бизнес-требованием. Например, блог-сайт может разрешать размещать комментарии, содержащие некоторую ограниченную HTML-разметку.

Классический подход заключается в попытке отфильтровать потенциально вредоносные теги и JavaScript. Вы можете попытаться реализовать это с помощью белого списка безопасных тегов и атрибутов, но из-за различий в механизмах синтаксического анализа браузеров и таких особенностей, как мутация XSS, этот подход крайне сложно реализовать безопасно.

Наименее плохой вариант — использовать библиотеку JavaScript, которая выполняет фильтрацию и кодирование в браузере пользователя, например DOMPurify. Другие библиотеки позволяют пользователям предоставлять контент в формате markdown и преобразовывать markdown в HTML. К сожалению, все эти библиотеки время от времени имеют уязвимости XSS, так что это не идеальное решение. Если вы используете одну из них, вам следует внимательно следить за обновлениями безопасности.

Примечание
Помимо JavaScript, в некоторых ситуациях вредным может оказаться и другой контент, такой как CSS и даже обычный HTML.

Атаки с использованием вредоносного CSS

Как предотвратить XSS с помощью шаблонизатора
Многие современные веб-сайты используют серверные шаблонизаторы, такие как Twig и Freemarker, для встраивания динамического контента в HTML. Обычно они определяют собственную систему экранирования. Например, в Twig можно использовать фильтр e()с аргументом, определяющим контекст:

{{ user.firstname | e('html') }}
Некоторые другие шаблонизаторы, такие как Jinja и React, по умолчанию экранируют динамический контент, что эффективно предотвращает большинство случаев XSS.

Мы рекомендуем внимательно изучить возможности экранирования, когда вы решаете, следует ли использовать тот или иной шаблонизатор или фреймворк.

Примечание
Если вы напрямую объединяете пользовательский ввод в строки шаблона, вы становитесь уязвимы для внедрения шаблона на стороне сервера, что часто более серьезно, чем XSS.

Как предотвратить XSS в PHP
В PHP есть встроенная функция для кодирования сущностей, называемая htmlentities. Эту функцию следует вызывать для экранирования ввода внутри HTML-контекста. Функцию следует вызывать с тремя аргументами:

Ваша входная строка.
ENT_QUOTES, который является флагом, указывающим, что все кавычки должны быть закодированы.
Набор символов, который в большинстве случаев должен быть UTF-8.
Например:

<?php echo htmlentities($input, ENT_QUOTES, 'UTF-8');?>
В контексте строки JavaScript вам необходимо экранировать ввод Unicode, как уже было описано. К сожалению, PHP не предоставляет API для экранирования Unicode строки. Вот код для этого в PHP:

<?phpfunction jsEscape($str) {
    $output = '';
    $str = str_split($str);
    for($i=0;$i<count($str);$i++) {
        $chrNum = ord($str[$i]);
        $chr = $str[$i];
        if($chrNum === 226) {
            if(isset($str[$i+1]) && ord($str[$i+1]) === 128) {
                if(isset($str[$i+2]) && ord($str[$i+2]) === 168) {
                    $output .= '\u2028';
                    $i += 2;
                    continue;
                }
                if(isset($str[$i+2]) && ord($str[$i+2]) === 169) {
                    $output .= '\u2029';
                    $i += 2;
                    continue;
                }
            }
        }
        switch($chr) {
            case "'":
            case '"':
            case "\n";
            case "\r";
            case "&";
            case "\\";
            case "<":
            case ">":
                $output .= sprintf("\\u%04x", $chrNum);
            break;
            default:
                $output .= $str[$i];
            break;
    }
    }
    return $output;
}
?>
Вот как использовать эту jsEscapeфункцию в PHP:

<script>x = '<?php echo jsEscape($_GET['x'])?>';</script>
В качестве альтернативы вы можете использовать шаблонизатор.

Как предотвратить XSS на стороне клиента в JavaScript
Чтобы экранировать пользовательский ввод в контексте HTML в JavaScript, вам нужен собственный HTML-кодер, поскольку JavaScript не предоставляет API для кодирования HTML. Вот пример кода JavaScript, который преобразует строку в HTML-сущности:

function htmlEncode(str){
    return String(str).replace(/[^\w. ]/gi, function(c){
        return '&#'+c.charCodeAt(0)+';';
    });
}
Затем вы можете использовать эту функцию следующим образом:

<script>document.body.innerHTML = htmlEncode(untrustedValue)</script>
Если ваш ввод находится внутри строки JavaScript, вам нужен кодировщик, который выполняет экранирование Unicode. Вот пример кодировщика Unicode:

function jsEscape(str){
    return String(str).replace(/[^\w. ]/gi, function(c){
        return '\\u'+('0000'+c.charCodeAt(0).toString(16)).slice(-4);
    });
}
Затем вы можете использовать эту функцию следующим образом:

<script>document.write('<script>x="'+jsEscape(untrustedValue)+'";<\/script>')</script>
Как предотвратить XSS в jQuery
Наиболее распространенная форма XSS в jQuery — это когда вы передаете пользовательский ввод в селектор jQuery. Веб-разработчики часто использовали location.hashи передавали его селектору, что вызывало XSS, поскольку jQuery отображал HTML. jQuery распознал эту проблему и исправил логику селектора, чтобы проверять, начинается ли ввод с хэша. Теперь jQuery отображает HTML только в том случае, если первый символ — <. Если вы передаете ненадежные данные селектору jQuery, убедитесь, что вы правильно экранируете значение с помощью jsEscapeфункции выше.

Смягчение последствий XSS с помощью политики безопасности контента (CSP)
Политика безопасности контента (CSP) — это последняя линия обороны от межсайтового скриптинга. Если ваша защита от XSS не срабатывает, вы можете использовать CSP для смягчения последствий XSS, ограничив действия злоумышленника.

CSP позволяет вам контролировать различные вещи, например, можно ли загружать внешние скрипты и будут ли выполняться встроенные скрипты. Для развертывания CSP вам необходимо включить заголовок ответа HTTP, вызываемый Content-Security-Policyсо значением, содержащим вашу политику.

Пример CSP выглядит следующим образом:

default-src 'self'; script-src 'self'; object-src 'none'; frame-src 'none'; base-uri 'none';
Эта политика определяет, что ресурсы, такие как изображения и скрипты, могут быть загружены только из того же источника, что и главная страница. Таким образом, даже если злоумышленник может успешно внедрить полезную нагрузку XSS, он может загрузить ресурсы только из текущего источника. Это значительно снижает вероятность того, что злоумышленник сможет использовать уязвимость XSS.

Если вам требуется загрузка внешних ресурсов, убедитесь, что вы разрешаете только те скрипты, которые не помогают злоумышленнику использовать ваш сайт. Например, если вы вносите в белый список определенные домены, то злоумышленник может загрузить любой скрипт с этих доменов. По возможности старайтесь размещать ресурсы на своем собственном домене.

Если это невозможно, то вы можете использовать политику на основе хэша или одноразового номера, чтобы разрешить скрипты на разных доменах. Одноразовый номер — это случайная строка, которая добавляется как атрибут скрипта или ресурса, который будет выполнен только в том случае, если случайная строка совпадает с сгенерированной сервером. Злоумышленник не может угадать случайную строку и, следовательно, не может вызвать скрипт или ресурс с допустимым одноразовым номером, и поэтому ресурс не будет выполнен.
